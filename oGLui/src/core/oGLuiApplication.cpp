/*
 * Copyright (C) 2009 Oliver Ney <oliver@dryder.de>
 *
 * This file is part of the OpenGL Overlay GUI Library (oGLui).
 *
 * oGLui is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with oGLui.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <core/oGLuiApplication.h>

#include <events/oGLuiEvent.h>
#include <widgets/oGLuiWidget.h>
#include <core/oGLuiSize.h>

#include <cstdlib>
#include <ctime>

oGLuiApplication *oGLuiApplication::m_self = 0;

oGLuiApplication::oGLuiApplication() :
		m_log("oGLui")
{
	m_self = this;

	srand(time(NULL));

	m_display = NULL;
	m_drawable = 0;
	m_context = 0;

	m_ogl_setup = false;

	m_style = new oGLuiSolidStyle();

#ifdef DEBUG
	m_log.writeLine(oGLuiLog::Info, "oGLui Application created");
#endif
}

oGLuiApplication::~oGLuiApplication()
{
	if(m_self == this)
		m_self = NULL;

	m_style->unref();

	while(!m_events.empty())
	{
		delete m_events.front().event;
		m_events.pop_front();
	}

#ifdef DEBUG
	m_log.writeLine(oGLuiLog::Info, "oGLui Application freed");
#endif
}

oGLuiLog &oGLuiApplication::log()
{
	return m_log;
}

void oGLuiApplication::setupOpenGL()
{
	if(isOpenGLSetUp())
		return;

	// Remove errors, which are not generated by ourselves
	glGetError();

	// Copied and altered from the Mumble Overlay code - thanks guys!
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glPushClientAttrib(GL_CLIENT_ALL_ATTRIB_BITS);

	OPENGL_CHECK;

	glGetIntegerv(GL_VIEWPORT, m_old_viewport);
	glGetIntegerv(GL_CURRENT_PROGRAM, &m_old_program);

	OPENGL_CHECK;

	glViewport(0, 0, screenWidth(), screenHeight());

	glMatrixMode(GL_PROJECTION);
	//glPushMatrix();
	glGetDoublev(GL_PROJECTION_MATRIX, m_old_projection);
	glLoadIdentity();
	glOrtho(0, screenWidth(), screenHeight(), 0, -100.0, 100.0);

	OPENGL_CHECK;

	glMatrixMode(GL_MODELVIEW);
	glGetDoublev(GL_MODELVIEW_MATRIX, m_old_model);
	//glPushMatrix();
	glLoadIdentity();

	OPENGL_CHECK;

	glMatrixMode(GL_TEXTURE);
	glGetDoublev(GL_TEXTURE_MATRIX, m_old_texture);
	//glPushMatrix();
	glLoadIdentity();

	OPENGL_CHECK;

	glDisable(GL_ALPHA_TEST);
	glDisable(GL_AUTO_NORMAL);
	glDisable(GL_COLOR_LOGIC_OP);
	glDisable(GL_COLOR_TABLE);
	glDisable(GL_CONVOLUTION_1D);
	glDisable(GL_CONVOLUTION_2D);
	glDisable(GL_CULL_FACE);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_DITHER);
	glDisable(GL_FOG);
	glDisable(GL_HISTOGRAM);
	glDisable(GL_INDEX_LOGIC_OP);
	glDisable(GL_LIGHTING);
	glDisable(GL_NORMALIZE);
	glDisable(GL_MINMAX);
	glDisable(GL_SEPARABLE_2D);
	glDisable(GL_SCISSOR_TEST);
	glDisable(GL_STENCIL_TEST);
	glDisable(GL_TEXTURE_GEN_Q);
	glDisable(GL_TEXTURE_GEN_R);
	glDisable(GL_TEXTURE_GEN_S);
	glDisable(GL_TEXTURE_GEN_T);

	OPENGL_CHECK;

	glRenderMode(GL_RENDER);

	OPENGL_CHECK;

	glDisableClientState(GL_VERTEX_ARRAY);
	glDisableClientState(GL_NORMAL_ARRAY);
	glDisableClientState(GL_COLOR_ARRAY);
	glDisableClientState(GL_INDEX_ARRAY);
	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
	glDisableClientState(GL_EDGE_FLAG_ARRAY);

	OPENGL_CHECK;

	glPixelStorei(GL_UNPACK_SWAP_BYTES, 0);
	glPixelStorei(GL_UNPACK_LSB_FIRST, 0);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
	glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	OPENGL_CHECK;

	GLint texunits = 1;

	glGetIntegerv(GL_MAX_TEXTURE_UNITS, &texunits);

	for(int i = texunits - 1; i >= 0; i--)
	{
		glActiveTexture(GL_TEXTURE0 + i);
		glDisable(GL_TEXTURE_1D);
		glDisable(GL_TEXTURE_2D);
		glDisable(GL_TEXTURE_3D);
	}

	OPENGL_CHECK;

	glDisable(GL_TEXTURE_CUBE_MAP);
	glDisable(GL_VERTEX_PROGRAM_ARB);
	glDisable(GL_FRAGMENT_PROGRAM_ARB);

	glUseProgram(0);

	OPENGL_CHECK;

	glEnable(GL_COLOR_MATERIAL);
	glEnable(GL_TEXTURE_2D);
	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	glMatrixMode(GL_MODELVIEW);

	glEnableClientState(GL_VERTEX_ARRAY);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);

	OPENGL_CHECK;

	m_ogl_setup = true;
}

bool oGLuiApplication::isOpenGLSetUp() const
{
	return m_ogl_setup;
}

void oGLuiApplication::restoreOpenGL()
{
	if(!isOpenGLSetUp())
		return;

	glMatrixMode(GL_TEXTURE);
	//glPopMatrix();
	glLoadMatrixd(m_old_texture);

	OPENGL_CHECK;

	glMatrixMode(GL_MODELVIEW);
	//glPopMatrix();
	glLoadMatrixd(m_old_model);

	OPENGL_CHECK;

	glMatrixMode(GL_PROJECTION);
	//glPopMatrix();
	glLoadMatrixd(m_old_projection);

	OPENGL_CHECK;

	glPopClientAttrib();
	glPopAttrib();

	OPENGL_CHECK;

	glViewport(m_old_viewport[0], m_old_viewport[1], m_old_viewport[2], m_old_viewport[3]);
	glUseProgram(m_old_program);

	OPENGL_CHECK;

	m_ogl_setup = false;
}

void oGLuiApplication::updateEnvironment(Display *p_display, GLXDrawable p_drawable)
{
	m_display = p_display;
	m_drawable = p_drawable;

	m_context = glXGetCurrentContext();
}

bool oGLuiApplication::hasEnvironment() const
{
	return (m_display != 0 && m_drawable != 0);
}

GLXContext oGLuiApplication::oGLContext() const
{
	return m_context;
}

unsigned int oGLuiApplication::screenWidth() const
{
	if(!m_display || !m_drawable)
		return 0;

	unsigned int ret = 0;
	glXQueryDrawable(m_display, m_drawable, GLX_WIDTH, &ret);

	return ret;
}

unsigned int oGLuiApplication::screenHeight() const
{
	if(!m_display || !m_drawable)
		return 0;

	unsigned int ret = 0;
	glXQueryDrawable(m_display, m_drawable, GLX_HEIGHT, &ret);

	return ret;
}

oGLuiSize oGLuiApplication::screenSize() const
{
	if(!m_display || !m_drawable)
		return oGLuiSize();

	oGLuiSize ret;
	unsigned int value = 0;

	glXQueryDrawable(m_display, m_drawable, GLX_WIDTH, &value);
	ret.setWidth(value);

	glXQueryDrawable(m_display, m_drawable, GLX_HEIGHT, &value);
	ret.setHeight(value);

	return ret;
}

void oGLuiApplication::registerWidget(oGLuiWidget *p_widget)
{
	std::list<oGLuiWidget*>::const_iterator iter = m_widgets.begin();
	for(; iter != m_widgets.end(); iter++)
	{
		if(*iter == p_widget)
			return;
	}

	m_widgets.push_back(p_widget);

#ifdef DEBUG
	m_log.writeLine(oGLuiLog::Info, "oGLuiApplication: New widget registered");
#endif
}

void oGLuiApplication::removeWidget(const oGLuiWidget *p_widget)
{
	if(m_widgets.empty())
		return;

	std::list<oGLuiWidget*>::iterator iter = m_widgets.begin();
	for(; iter != m_widgets.end(); iter++)
	{
		if(*iter == p_widget)
		{
			m_widgets.erase(iter);
#ifdef DEBUG
			m_log.writeLine(oGLuiLog::Info, "oGLuiApplication: Widget removed");
#endif
			return;
		}
	}
}

void oGLuiApplication::removeEventsFor(oGLuiObject *p_recipient)
{
	if(!p_recipient || m_events.empty())
		return;

	std::list<event_container>::iterator iter;
	for(iter = m_events.begin(); iter != m_events.end(); iter++)
	{
		if((*iter).recipient == p_recipient)
		{
			std::list<event_container>::iterator current(iter);
			iter--;
			delete (*current).event;
			m_events.erase(current);
		}
	}
}

void oGLuiApplication::postEvent(oGLuiObject *p_recipient, oGLuiEvent *p_event)
{
	if(!p_recipient || !p_event || p_event->isAccepted())
		return;

	// Remove duplicate paint events
	if(p_event->type() == oGLuiEvent::ETPaint && !m_events.empty())
	{
		std::list<event_container>::iterator iter;
		for(iter = m_events.begin(); iter != m_events.end(); iter++)
		{
			if((*iter).recipient == p_recipient && (*iter).event->type() == oGLuiEvent::ETPaint)
			{
				std::list<event_container>::iterator current(iter);
				iter--;
				delete (*current).event;
				m_events.erase(current);
			}
		}
	}

	event_container ec;
	ec.event = p_event;
	ec.recipient = p_recipient;

	m_events.push_back(ec);
}

void oGLuiApplication::processEvents()
{
	while(!m_events.empty())
	{
		while(!m_events.front().event->isAccepted())
		{
			m_events.front().recipient->eventHandler(m_events.front().event);
			if(!m_events.front().event->isAccepted())
			{
				if(!m_events.front().recipient->parent())
					break;
				else
					m_events.front().recipient = m_events.front().recipient->parent();
			}
		}

		delete m_events.front().event;
		m_events.pop_front();
	}
}

void oGLuiApplication::keyboardInput(const XKeyEvent *p_event)
{
	if(!p_event)
		return;
}

void oGLuiApplication::mouseMove(const XMotionEvent *p_event)
{
	if(!p_event)
		return;

	m_pointer.move(p_event->x, p_event->y);
}

void oGLuiApplication::mouseInput(const XButtonEvent *p_event)
{
	if(!p_event)
		return;
}

oGLuiPointer &oGLuiApplication::pointer()
{
	return m_pointer;
}

void oGLuiApplication::paintAll()
{
	if(!hasEnvironment())
		return;

	setupOpenGL();

	std::list<oGLuiWidget*>::const_iterator iter = m_widgets.begin();
	for(; iter != m_widgets.end(); iter++)
		(*iter)->paintTexture();

	m_pointer.paintTexture();

	restoreOpenGL();
}

void oGLuiApplication::setStyle(oGLuiStyle *p_style)
{
	if(p_style)
	{
		m_style->unref();
		m_style = p_style;
		m_style->ref();
	}
}

const oGLuiStyle *oGLuiApplication::style() const
{
	return m_style;
}
